#include <Eigen/Dense>
#include <vector>
#include <map>
#include <boost/random/mersenne_twister.hpp>
#include <boost/math/tools/tuple.hpp>
#include <boost/math/tools/roots.hpp>
namespace Multivariate{
	//! Multivariate Student's t Distribution
	/*!
	\details This class provides the functionality of calculating the probability density value, cumulative probability density value and generate random samples from a multivariate Student's t distribution.

	It uses the [Eigen](http://eigen.tuxfamily.org) libraries for linear algebra computation and [Boost](http://www.boost.org/) libraries for statistical distribution and random number generation.

	The algorithm for cdf calculation is based on [A. Genz & F. Bretz (2002)](http://www.math.wsu.edu/faculty/genz/homepage)

	To generate samples a [boost::random::mt19937](http://www.boost.org/doc/libs/1_55_0/doc/html/boost/random/mt19937.html) random number generator is used and seeded with [std::time(NULL)](http://www.cplusplus.com/reference/ctime/time/).<br>
	If you construct multiple instances of this class, to avoid the generated samples to be the same, you should supply a different seed. To do so, for example, you can call `MyDistribution.SetRandomSeed(MyDistribution.GetCurrentSeed()+1U);`

	Please refer to the \ref examples page for usage examples.

	\remark This class is re-entrant
	\date November 2013
	\license This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.<br><br>
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.<br><br>
	You should have received a copy of the GNU Lesser General Public License
	along with this program.  If not, see [gnu.org](http://www.gnu.org/licenses/).
	*/
	class tDistribution{
	private:
		mutable boost::random::mt19937 RandNumGen;
		unsigned int Dim;
		Eigen::VectorXd LocationVect;
		Eigen::MatrixXd ScaleMatrix;
		unsigned int DegreesOfFreedom;
		bool AllValid;
		bool CheckValidity();
		tDistribution(const tDistribution& a);
		tDistribution& operator=(const tDistribution& a);
		unsigned int CurrentSeed;
		double ProbToFind;
		boost::math::tuple<double, double> operator()(double x);
	public:
		//! Construct a multivariate student's t with the given parameters
		/*!
		\param Dimension The dimensionality of the distribution (supports also univariate student's t distributions in case this is 1)
		\param DegFreedom The degrees of freedom of the distribution
		\param locVect The location vector
		\param ScaleMatr The scale matrix
		\details Construct a multivariate student's t distribution.
	
		In case:
		- The Dimension is 0
		- The Degrees of freedom are 0
		- The location vector has a number of elements different from the Dimension
		- The ScaleMatr is not square
		- The ScaleMatr is not symmetric
		- The ScaleMatr is not semi-positive definite
		- The ScaleMatr has a number of rows different from the Dimension
	
		The class will be considered invalid (it can be checked using `IsValid()`) and won't produce any result until the problem is fixed.
		*/
		tDistribution(unsigned int Dimension,unsigned int DegFreedom,const Eigen::VectorXd& locVect,const Eigen::MatrixXd& ScaleMatr);
		//! Construct a multivariate standardized student's t
		/*!
		\param Dimension The dimensionality of the multivariate normal (supports also univariate Gaussian distributions in case this is 1)
		\param DegFreedom The degrees of freedom of the distribution
		\details Construct a multivariate student's t distribution with all location parameters set to 0 and scale matrix set to the identity.
	
		In case the Dimension or the DegFreedom are 0 the class will be considered invalid (it can be checked using `IsValid()`) and won't produce any result until the problem is fixed.

		If no argument is specified, a univariate standardized student's t with 1 degree of freedom, is created
		*/
		tDistribution(unsigned int Dimension=1U,unsigned int DegFreedom=1U);
		//! Check if the distribution is valid
		/*!
		\return A boolean determining if the structure of the distribution is valid
		\details If this function returns false the structure of the distribution is meaningless and no result will be produced until the invalid parameters are cured.
		*/
		bool IsValid() const {return AllValid;}
		//! Set the random number generator seed
		/*!
		\param NewSeed the new random seed
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa GetCurrentSeed()
		*/
		void SetRandomSeed(unsigned int NewSeed);
		//! Get the random number generator seed
		/*!
		\return The random number generator seed.
		\details This function return the seed that was used to initialize the random number generator.
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa SetRandomSeed()
		*/
		unsigned int GetCurrentSeed()const{return CurrentSeed;}
		//! Set the expected values vector
		/*!
		\param mVect the vector of new values for the location vector
		\return A boolean determining if the location vector was changed successfully
		\details This function attempts to set the location vector to the new values supplied.
	
		If the dimension of the vector is different from the dimension of the distribution the location vector is not changed and false is returned
		\sa GetLocationVector()
		*/
		bool SetLocationVector(const Eigen::VectorXd& mVect);
		//! Set the expected values vector
		/*!
		\param mVect the vector of new values for the location vector
		\details This is an overloaded version of SetLocationVector(const Eigen::VectorXd&)
		*/
		bool SetLocationVector(const std::vector<double>& mVect);
		//! Set the dimensionality of the distribution
		/*!
		\param Dimension the new dimensionality of the distribution 
		\return A boolean determining if the dimensionality was changed successfully
		\details This function will try to change the dimensionality of the distribution (e.g. 2 for bivariate, 3 for trivariate, etc.)
	
		All the components of the location vector will be reset to 0 and the scale matrix will default to an identity matrix

		If the argument passed is 0 the dimensionality will not be changed and the function will return false

		\sa GetDimension()
		*/
		bool SetDimension(unsigned int Dimension);
		//! Set the scale matrix of the distribution
		/*!
		\param SclMatr the new scale matrix of the distribution 
		\return A boolean determining if the scale matrix of the distribution was changed successfully
		\details This function tries to set the scale matrix of the distribution to the new one.

		In case:
		- The scale matrix is not square
		- The scale matrix is not symmetric
		- The scale matrix is not semi-positive definite
		- The scale matrix has a number of rows different from the Dimension

		The scale matrix of the distribution will not be changed and this function will return false

		\sa GetScaleMatrix()
		*/
		bool SetScaleMatrix(const Eigen::MatrixXd& SclMatr);
		//! Set the scale matrix of the distribution
		/*!
		\param mVect a vector containing the elements of the new scale matrix of the distribution
		\param RowWise if it's set to true (the default) the matrix will be filled by row. If it's false it will be filled by columns
		\return A boolean determining if the scale matrix of the distribution was changed successfully
		\details This function tries to set the scale matrix of the distribution to the new one.

		Constructs square a matrix with number of rows equal to the dimensionality of the distribution, it is then filled with the values supplied in order according to the RowWise parameter

		In case:
		- The vector size is different from the square of the distribution dimensionality
		- The scale matrix is not symmetric
		- The scale matrix is not semi-positive definite
		- The scale matrix has a number of rows different from the Dimension

		The scale matrix of the distribution will not be changed and this function will return false

		\sa GetScaleMatrix()
		*/
		bool SetScaleMatrix(const std::vector<double>& mVect, bool RowWise=true);
		//! Set the degrees of freedom of the distribution
		/*!
		\param a The number of degrees of freedom of the distribution
		\return A boolean determining if the degrees of freedom of the distribution were changed successfully
		\details This function tries to set the degrees of freedom of the distribution to the new ones.

		In case a is less than 1 the degrees of freedom of the distribution will not be changed and this function will return false

		\sa GetDegreesOfFreedom()
		*/
		bool SetDegreesOfFreedom(unsigned int a);
		//! Get the degrees of freedom of the distribution
		/*!
		\return The number of degrees of freedom of the distribution
		\details This function returns the number of degrees of freedom of the distribution

		\sa SetDegreesOfFreedom()
		*/
		unsigned int GetDimension() const {return Dim;}
		const Eigen::VectorXd& GetLocationVector() const {return LocationVect;}
		const Eigen::MatrixXd& GetScaleMatrix() const {return ScaleMatrix;}
		unsigned int GetDegreesOfFreedom() const {return DegreesOfFreedom;}
		Eigen::RowVectorXd ExtractSample() const{return ExtractSamples(1U);}
		std::vector<double> ExtractSampleVector() const;
		Eigen::MatrixXd ExtractSamples(unsigned int NumSamples) const;
		std::map<unsigned int,std::vector<double> > ExtractSamplesMap(unsigned int NumSamples) const;
		double GetDensity(const Eigen::VectorXd& Coordinates, bool GetLogDensity=false)const;
		double GetDensity(const std::vector<double>& Coordinates, bool GetLogDensity=false)const;
		double GetCumulativeDesity(const std::vector<double>& Coordinates, bool UseGenz=true, unsigned int NumSimul=500000)const;
		double GetCumulativeDesity(const Eigen::VectorXd& Coordinates, bool UseGenz=true, unsigned int NumSimul=500000)const;
		Eigen::VectorXd GetQuantile(double Prob) const;
		std::vector<double> GetQuantileVector(double Prob) const;
#ifdef mvNormSamplerUnsafeMethods

#endif
		template <class F, class T> friend T boost::math::tools::newton_raphson_iterate(F f, T guess, T min, T max, int digits);
		template <class F, class T>	friend T boost::math::tools::newton_raphson_iterate(F f, T guess, T min, T max, int digits, boost::uintmax_t& max_iter);
		template <class F, class T> friend void boost::math::tools::detail::handle_zero_derivative(F f,T& last_f0,const T& f0,T& delta,T& result,T& guess,const T& min,const T& max);
	};
}