#ifndef AbstractDistribution_h__
#define AbstractDistribution_h__
#include <Eigen/Dense>
#include <vector>
#include <map>
#include <boost/random/mersenne_twister.hpp>
//! Namespace where all classes are defined
namespace Multivariate{
	//! Distributions base class
	/*!
	\details Class that works as an interface to distributions
	
	To generate samples a [boost::random::mt19937](http://www.boost.org/doc/libs/1_55_0/doc/html/boost/random/mt19937.html) random number generator is used and seeded with [std::time(NULL)](http://www.cplusplus.com/reference/ctime/time/).<br>
	If you construct multiple instances of derived classes, to avoid the generated samples to be the same, you should supply a different seed. To do so, for example, you can call `MyDistribution.SetRandomSeed(MyDistribution.GetCurrentSeed()+1U);`
	\note This class is abstract
	\date November 2013
	\license This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.<br><br>
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.<br><br>
	Here, you can find a copy of the \ref LicensePage.
	Alternatively, see [gnu.org](http://www.gnu.org/licenses/).
	*/
	class AbstarctDistribution{
	protected:
		AbstarctDistribution(unsigned int Dimension=1U);
		mutable boost::random::mt19937 RandNumGen;
		unsigned int Dim;
		bool AllValid;
		unsigned int CurrentSeed;
	public:
		//! Check if the distribution is valid
		/*!
		\return A boolean determining if the structure of the distribution is valid
		\details If this function returns false the structure of the distribution is meaningless and no result will be produced until the invalid parameters are cured.
		*/
		bool IsValid() const {return AllValid;}
		//! Set the random number generator seed
		/*!
		\param NewSeed the new random seed
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa GetCurrentSeed()
		*/
		void SetRandomSeed(unsigned int NewSeed);
		//! Get the random number generator seed
		/*!
		\return The random number generator seed.
		\details This function return the seed that was used to initialize the random number generator.
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa SetRandomSeed()
		*/
		unsigned int GetCurrentSeed()const{return CurrentSeed;}
		//! Get the dimensionality of the distribution
		/*!
		\return The current dimensionality of the distribution
		\sa SetDimension()
		*/
		unsigned int GetDimension() const {return Dim;}

		//! Set the dimensionality of the distribution
		/*!
		\param Dimension the new dimensionality of the distribution 
		\return A boolean determining if the dimensionality was changed successfully
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		\sa GetDimension()
		*/
		virtual bool SetDimension(unsigned int Dimension) =0;
		//! Generates multiple simulations from the distribution
		/*!
		\param NumSamples The number of simulation to run
		\return A matrix with columns equal to the dimensionality of the distribution and rows equal to the number of simulations
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual Eigen::MatrixXd ExtractSamples(unsigned int NumSamples) const =0;
		//! Computes the probability density function of the distribution in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual double GetDensity(const Eigen::VectorXd& Coordinates)const =0;
		//! Computes the cumulative density function of the distribution in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the cdf should be computed
		\return The value of the cumulative density function
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual double GetCumulativeDesity(const Eigen::VectorXd& Coordinates)const =0;
		//! Extracts samples from the distribution and returns their marginal CDF
		/*!
		\param NumSamples The number of simulation to run
		\return A matrix with columns equal to the dimensionality of the distribution and rows equal to the number of simulations
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		 */
		virtual Eigen::MatrixXd ExtractSamplesCDF(unsigned int NumSamples) const =0;
		//! Computes the inverse cumulative density function of the distribution in correspondence of the supplied probability
		/*!
		\param Prob The probability for which the corresponding quantile must be found
		\return A vector containing the coordinates of the quantile
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual Eigen::VectorXd GetQuantile(double Prob)const =0;

		//! Generates a single simulation from the distribution
		/*!
		\return A row vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the distribution
		\details This is equal to calling `ExtractSamples(1U)`
		\sa ExtractSamples()
		*/
		virtual Eigen::RowVectorXd ExtractSample() const{return ExtractSamples(1U);}
		//! Generates a single simulation from the distribution
		/*!
		\return A vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the distribution
		\details This is equivalent to ExtractSample() but returns an std::vector intead of an Eigen::RowVectorXd
		\sa ExtractSamples()
		*/
		virtual std::vector<double> ExtractSampleVector() const;
		//! Generates multiple simulations from the distribution
		/*!
		\param NumSamples The number of simulation to run
		\return A map that has as keys the index of the dimension (starting from 0) and as values a vector containing the simulation results for that dimension
		\details This function generates NumSamples simulation from the current distribution and returns them in a map form.
	
		If NumSamples is 0 or the distribution is invalid, an empty map is returned
		*/
		virtual std::map<unsigned int,std::vector<double> > ExtractSamplesMap(unsigned int NumSamples) const;
		//! Computes the probability density function of the distribution in correspondence of the supplied coordinates
		/*!
		\param Coordinates  A vector containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is an overloaded version of GetDensity(const Eigen::VectorXd& Coordinates, bool GetLogDensity)const
		*/
		virtual double GetDensity(const std::vector<double>& Coordinates)const;
		//! Computes the cumulative density function of the distribution in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the cdf should be computed
		\return The value of the cumulative density function
		\details This is an overloaded version of GetCumulativeDesity(const Eigen::VectorXd&, bool, unsigned int)const
		*/
		virtual double GetCumulativeDesity(const std::vector<double>& Coordinates)const;
		//! Computes the inverse cumulative density function of the distribution in correspondence of the supplied probability
		/*!
		\return A vector containing the coordinates of the quantile
		\details This is equivalent to GetQuantile() but returns an std::vector intead of an Eigen::VectorXd
		*/
		virtual std::vector<double> GetQuantileVector(double Prob)const;
		//! Generates a single simulation from the distribution and returns its marginal CDF
		/*!
		\return A vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the distribution
		\details This is equal to calling `ExtractSamplesCDF(1U)`
		\sa ExtractSamplesCDF()
		*/
		virtual Eigen::RowVectorXd ExtractSampleCDF() const{return ExtractSamplesCDF(1U);}
		//! Generates a single simulation from the distribution and returns its marginal CDF
		/*!
		\return A vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the distribution
		\details This is equivalent to ExtractSampleCDF() but returns an std::vector intead of an Eigen::RowVectorXd
		\sa ExtractSamplesCDF()
		*/
		virtual std::vector<double> ExtractSampleCDFVect() const;
		//! Extracts samples from the distribution and returns their marginal CDF
		/*!
		\param NumSamples The number of simulation to run
		\return A matrix with columns equal to the dimensionality of the distribution and rows equal to the number of simulations
		\details This function generates NumSamples simulation from the current distribution, computes the marginal cumulative density function for each of them and returns them in a map form.
	
		This function can be seen as simulation extractions from a copula

		If NumSamples is 0 or the distribution is invalid, a null matrix is returned
		 */
		virtual std::map<unsigned int,std::vector<double> > ExtractSamplesCDFMap(unsigned int NumSamples) const;

#ifdef mvPackageUnsafeMethods 
		/** \name Unsafe Methods
		The methods in this group use unsafe memory access or return arrays allocated on the heap that must be manually deleted.

		These functions are normally not compiled for safety reasons. To use them, the **mvPackageUnsafeMethods** symbol must be defined at compile time
		\{
		*/
		//! Computes the inverse cumulative density function of the distribution in correspondence of the supplied probability
		/*!
		\return A dynamically allocated array containing the coordinates of the quantile
		\details This is equivalent to GetQuantile() but returns an array intead of an Eigen::VectorXd. If it can't be calculated, NULL is returned
		\warning This function will return a matrix allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		virtual double* GetQuantileArray(double Prob);
		//! Computes the cumulative density function of the distribution in correspondence of the supplied coordinates
		/*!
		\param Coordinates An array containing the coordinates of the point for which the cdf should be computed
		\return The value of the cumulative density function
		\details This is an overloaded version of GetCumulativeDesity(const Eigen::VectorXd& Coordinates, bool UseGenz, unsigned int NumSimul)
		\warning This function will search for a number of elements equal to the dimensionality of the distribution in the array. This may mean accessing unallocated memory blocks if the supplied array is not big enough
		*/
		virtual double GetCumulativeDesity(double* Coordinates)const;
		/**
		\brief Computes the probability density function of the distribution in correspondence of the supplied coordinates
		\param Coordinates An array containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is an overloaded version of GetDensity(const Eigen::VectorXd&, bool)
		\warning This function will search for a number of elements equal to the dimensionality of the distribution in the array. This may mean accessing unallocated memory blocks if the supplied array is not big enough
		*/
		virtual double GetDensity(double* Coordinates)const;
		/**
		\brief Generates a single simulation from the distribution
		\return A dynamically allocated array with number of elements equal to the dimensionality of the distribution representing a single extraction from the distribution
		\details This is equivalent to ExtractSample() but returns an array intead of an Eigen::RowVectorXd. If it can't be calculated, NULL is returned
		\warning This function will return an array allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		virtual double* ExtractSampleArray() const;
		/**
		\brief Generates a single simulation from the distribution
		\param NumSamples The number of simulation to run
		\return A dynamically allocated matrix with number of columns equal to the dimensionality of the distribution and number of rows equal to the number of simulations representing multiple draws from the distribution
		\details This is equivalent to ExtractSamples() but returns a matrix intead of an Eigen::MatrixXd. If it can't be calculated, NULL is returned
		\warning This function will return a matrix allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		virtual double** ExtractSamplesMatix(unsigned int NumSamples) const;
		/**
		\brief Generates a single simulation from the distribution and returns its marginal CDF
		\return A dynamically allocated array with number of elements equal to the dimensionality of the distribution representing a single extraction from the distribution
		\details This is equivalent to ExtractSampleCDF() but returns an array intead of an Eigen::RowVectorXd. If it can't be calculated, NULL is returned
		\warning This function will return an array allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		virtual double* ExtractSampleCDFArray() const;
		/**
		\brief Generates a single simulation from the distribution and returns its marginal CDF
		\param NumSamples The number of simulation to run
		\return A dynamically allocated matrix with number of columns equal to the dimensionality of the distribution and number of rows equal to the number of simulations representing multiple draws from the distribution
		\details This is equivalent to ExtractSamplesCDF() but returns a matrix intead of an Eigen::MatrixXd. If it can't be calculated, NULL is returned
		\warning This function will return a matrix allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		virtual double** ExtractSamplesCDFMatix(unsigned int NumSamples) const;
		/// \}
#endif
	};
}
#endif // AbstractDistribution_h__