#ifndef AbstarctCopula_h__
#define AbstarctCopula_h__
#include "AbstractDistribution.h"
namespace Multivariate{
	//! Copulas base class
	/*!
	\details Class that works as an interface to copulas
	
	To generate samples a [boost::random::mt19937](http://www.boost.org/doc/libs/1_55_0/doc/html/boost/random/mt19937.html) random number generator is used and seeded with [std::time(NULL)](http://www.cplusplus.com/reference/ctime/time/).<br>
	If you construct multiple instances of derived classes, to avoid the generated samples to be the same, you should supply a different seed. To do so, for example, you can call `MyDistribution.SetRandomSeed(MyDistribution.GetCurrentSeed()+1U);`
	\note This class is abstract
	\date November 2013
	\license This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.<br><br>
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.<br><br>
	Here, you can find a copy of the \ref LicensePage.
	Alternatively, see [gnu.org](http://www.gnu.org/licenses/).
	*/
	class AbstarctCopula{
	protected:
		AbstarctDistribution* BaseDist;
		AbstarctCopula():BaseDist(NULL){}
		bool CheckCoordinatesInput(const Eigen::VectorXd& Coordinates) const;
	public:
		//! Check if the copula is valid
		/*!
		\return A boolean determining if the structure of the copula is valid
		\details If this function returns false the structure of the copula is meaningless and no result will be produced until the invalid parameters are cured.
		*/
		bool IsValid() const {return BaseDist->IsValid() && BaseDist->GetDimension()>1U;}
		//! Set the random number generator seed
		/*!
		\param NewSeed the new random seed
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa GetCurrentSeed()
		*/
		void SetRandomSeed(unsigned int NewSeed){return BaseDist->SetRandomSeed(NewSeed);}
		//! Get the random number generator seed
		/*!
		\return The random number generator seed.
		\details This function return the seed that was used to initialize the random number generator.
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa SetRandomSeed()
		*/
		unsigned int GetCurrentSeed()const{return BaseDist->GetCurrentSeed();}
		//! Get the dimensionality of the copula
		/*!
		\return The current dimensionality of the copula
		\sa SetDimension()
		*/
		unsigned int GetDimension() const {return BaseDist->GetDimension();}
		//! Set the dimensionality of the copula
		/*!
		\param Dimension the new dimensionality of the copula 
		\return A boolean determining if the dimensionality was changed successfully
		\details This function will try to change the dimensionality of the copula (e.g. 2 for bivariate, 3 for trivariate, etc.)

		If the argument passed is less than 2 the dimensionality will not be changed and the function will return false

		\sa GetDimension()
		*/
		bool SetDimension(unsigned int Dimension){if(Dimension>1U) return BaseDist->SetDimension(Dimension); else return false;}
		//! Generates multiple simulations from the copula
		/*!
		\param NumSamples The number of simulation to run
		\return A matrix with columns equal to the dimensionality of the copula and rows equal to the number of simulations
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual Eigen::MatrixXd ExtractSamples(unsigned int NumSamples)const =0;
		//! Computes the probability density function of the copula in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual double GetDensity(const Eigen::VectorXd& Coordinates)const =0;
		//! Computes the copula function in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the cdf should be computed
		\return The value of the copula function
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual double GetCumulativeDesity(const Eigen::VectorXd& Coordinates)const =0;
		//! Computes the inverse copula function in correspondence of the supplied probability
		/*!
		\param Prob The probability for which the corresponding quantile must be found
		\return A vector containing the coordinates of the quantile
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual Eigen::VectorXd GetQuantile(double Prob)const =0;
		//! Generates a single simulation from the copula
		/*!
		\return A row vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the copula
		\details This is equal to calling `ExtractSamples(1U)`
		\sa ExtractSamples()
		*/
		Eigen::RowVectorXd ExtractSample() const{if(BaseDist->GetDimension()>1U) return ExtractSamples(1U); else return Eigen::RowVectorXd();}
		//! Generates a single simulation from the copula
		/*!
		\return A vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the copula
		\details This is equivalent to ExtractSample() but returns an std::vector intead of an Eigen::RowVectorXd
		\sa ExtractSamples()
		*/
		std::vector<double> ExtractSampleVector() const;
		//! Generates multiple simulations from the copula
		/*!
		\param NumSamples The number of simulation to run
		\return A map that has as keys the index of the dimension (starting from 0) and as values a vector containing the simulation results for that dimension
		\details This function generates NumSamples simulation from the current copula and returns them in a map form.
	
		If NumSamples is 0 or the distribution is invalid, an empty map is returned
		*/
		std::map<unsigned int,std::vector<double> > ExtractSamplesMap(unsigned int NumSamples) const;
		//! Computes the probability density function of the copula in correspondence of the supplied coordinates
		/*!
		\param Coordinates  A vector containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is an overloaded version of GetDensity(const Eigen::VectorXd& Coordinates, bool GetLogDensity)const
		*/
		double GetDensity(const std::vector<double>& Coordinates)const;
		//! Computes the copula function in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the cdf should be computed
		\return The value of the copula function
		\details This is an overloaded version of GetCumulativeDesity(const Eigen::VectorXd&, bool, unsigned int)const
		*/
		double GetCumulativeDesity(const std::vector<double>& Coordinates)const;
		//! Computes the inverse copula function in correspondence of the supplied probability
		/*!
		\return A vector containing the coordinates of the quantile
		\details This is equivalent to GetQuantile() but returns an std::vector intead of an Eigen::VectorXd
		*/
		std::vector<double> GetQuantileVector(double Prob)const;
#ifdef mvPackageUnsafeMethods 
		/** \name Unsafe Methods
		The methods in this group use unsafe memory access or return arrays allocated on the heap that must be manually deleted.

		These functions are normally not compiled for safety reasons. To use them, the **mvPackageUnsafeMethods** symbol must be defined at compile time
		\{
		*/
		//! Computes the inverse copula function in correspondence of the supplied probability
		/*!
		\return A dynamically allocated array containing the coordinates of the quantile
		\details This is equivalent to GetQuantile() but returns an array intead of an Eigen::VectorXd. If it can't be calculated, NULL is returned
		\warning This function will return a matrix allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		double* GetQuantileArray(double Prob);
		//! Computes the copula function in correspondence of the supplied coordinates
		/*!
		\param Coordinates An array containing the coordinates of the point for which the cdf should be computed
		\return The value of the copula function
		\details This is an overloaded version of GetCumulativeDesity(const Eigen::VectorXd& Coordinates, bool UseGenz, unsigned int NumSimul)
		\warning This function will search for a number of elements equal to the dimensionality of the distribution in the array. This may mean accessing unallocated memory blocks if the supplied array is not big enough
		*/
		double GetCumulativeDesity(double* Coordinates)const;
		/**
		\brief Computes the probability density function of the copula in correspondence of the supplied coordinates
		\param Coordinates An array containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is an overloaded version of GetDensity(const Eigen::VectorXd&, bool)
		\warning This function will search for a number of elements equal to the dimensionality of the distribution in the array. This may mean accessing unallocated memory blocks if the supplied array is not big enough
		*/
		double GetDensity(double* Coordinates)const;
		/**
		\brief Generates a single simulation from the copula
		\return A dynamically allocated array with number of elements equal to the dimensionality of the copula representing a single extraction from the distribution
		\details This is equivalent to ExtractSample() but returns an array intead of an Eigen::RowVectorXd. If it can't be calculated, NULL is returned
		\warning This function will return an array allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		double* ExtractSampleArray() const;
		/**
		\brief Generates a single simulation from the copula
		\param NumSamples The number of simulation to run
		\return A dynamically allocated matrix with number of columns equal to the dimensionality of the copula and number of rows equal to the number of simulations representing multiple draws from the copula
		\details This is equivalent to ExtractSamples() but returns a matrix intead of an Eigen::MatrixXd. If it can't be calculated, NULL is returned
		\warning This function will return a matrix allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		double** ExtractSamplesMatix(unsigned int NumSamples) const;
		/// \}
#endif
	};
}
#endif // AbstarctCopula_h__