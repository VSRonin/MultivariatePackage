#ifndef AbstarctArchimedeanCopula_h__
#define AbstarctArchimedeanCopula_h__
#include <Eigen/Dense>
#include <vector>
#include <map>
#include <boost/random/mersenne_twister.hpp>
#include <boost/math/tools/tuple.hpp>
namespace Multivariate{
	//! Archimedean Copulas base class
	/*!
	\details Class that works as an interface to Archimedean copulas.
	
	An Archimedean copula of dimension k is defined as:<br>
	\f$ C(u_1 , \cdots , u_k ; \theta)=\psi^{-1}(\psi(u_1 ; \theta)+ \cdots + \psi(u_k ; \theta); \theta) \f$ <br>
	where \f$ \theta \f$ is the dependence parameter ruling the distribution and \f$ \psi(.) \f$ is the generator function.
	
	To generate samples a [boost::random::mt19937](http://www.boost.org/doc/libs/1_55_0/doc/html/boost/random/mt19937.html) random number generator is used and seeded with [std::time(NULL)](http://www.cplusplus.com/reference/ctime/time/).<br>
	If you construct multiple instances of derived classes, to avoid the generated samples to be the same, you should supply a different seed. To do so, for example, you can call `MyDistribution.SetRandomSeed(MyDistribution.GetCurrentSeed()+1U);`
	\note This class is abstract
	\date November 2013
	\license This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.<br><br>
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.<br><br>
	Here, you can find a copy of the \ref LicensePage.
	Alternatively, see [gnu.org](http://www.gnu.org/licenses/).
	*/
	class AbstractArchimedean{
	protected:
		AbstractArchimedean(unsigned int Dimension,double theta);
		double Theta;
		unsigned int Dim;
		mutable boost::random::mt19937 RandNumGen;
		bool AllValid;
		unsigned int CurrentSeed;
		virtual bool CheckValidity();
		virtual double GeneratorFunction(double x)const =0;
		virtual double GeneratorInverseFunction(double x)const =0;
		virtual double GeneratorFunctionDerivative(double x)const =0;
		virtual double GeneratorInverseFunctionDerivative(double x)const =0;
		virtual double SimulateGeneratorInverseFourier()const =0;
		bool CheckCoordinatesInput(const Eigen::VectorXd& Coordinates) const;
		virtual boost::math::tuple<double, double> operator()(double x);
		double ProbToFind;
	public:
		//! Set the dependence parameter
		/*!
		\return Always true
		\details This function sets the value of the parameter \f$ \theta \f$ that governs the dependence
		
		This implementation won't perform any check on \f$ \theta \f$. See the derived class documentation for specific restrictions

		\sa GetTheta()
		*/
		virtual bool SetTheta(double t){Theta=t; return true;}
		//! Get the dependence parameter
		/*!
		\return The dependence parameter
		\details This function returns the value of the parameter \f$ \theta \f$ that governs the dependence
		\sa SetTheta()
		*/
		double GetTheta() const {return Theta;}
		//! Check if the copula is valid
		/*!
		\return A boolean determining if the structure of the copula is valid
		\details If this function returns false the structure of the copula is meaningless and no result will be produced until the invalid parameters are cured.
		*/
		bool IsValid() const {return AllValid;}
		//! Set the random number generator seed
		/*!
		\param NewSeed the new random seed
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa GetCurrentSeed()
		*/
		void SetRandomSeed(unsigned int NewSeed);
		//! Get the random number generator seed
		/*!
		\return The random number generator seed.
		\details This function return the seed that was used to initialize the random number generator.
		\note This seed is different from the srand() seed and, even with the same seed, random number generated by the internal generator will be different by those generated by rand()
		\sa SetRandomSeed()
		*/
		unsigned int GetCurrentSeed()const{return CurrentSeed;}
		//! Get the dimensionality of the copula
		/*!
		\return The current dimensionality of the copula
		\sa SetDimension()
		*/
		unsigned int GetDimension() const {return Dim;}
		//! Set the dimensionality of the copula
		/*!
		\param Dimension the new dimensionality of the copula 
		\return A boolean determining if the dimensionality was changed successfully
		\details This function will try to change the dimensionality of the copula (e.g. 2 for bivariate, 3 for trivariate, etc.)

		If the argument passed is less than 2 the dimensionality will not be changed and the function will return false

		\sa GetDimension()
		*/
		bool SetDimension(unsigned int Dimension){if(Dimension>1U){ Dim=Dimension; CheckValidity(); return true;} return false;}
		//! Generates multiple simulations from the copula
		/*!
		\param NumSamples The number of simulation to run
		\return A matrix with columns equal to the dimensionality of the copula and rows equal to the number of simulations
		\details This function uses the algorithm described by [Albert W. Marshall and Ingram Olkin, Families of Multivariate Distributions, Journal of the American Statistical Association, Vol. 83, No. 403 (Sep., 1988), pp. 834-841](http://www.jstor.org/stable/2289314) to sample from the copula distribution.
		
		If NumSamples is less than 1 or the distribution is invalid, an empty matrix will be returned
		*/
		virtual Eigen::MatrixXd ExtractSamples(unsigned int NumSamples)const;
		//! Computes the probability density function of the copula in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual double GetDensity(const Eigen::VectorXd& Coordinates)const;
		//! Computes the copula function in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the cdf should be computed
		\return The value of the copula function
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual double GetCumulativeDesity(const Eigen::VectorXd& Coordinates)const;
		//! Computes the inverse copula function in correspondence of the supplied probability
		/*!
		\param Prob The probability for which the corresponding quantile must be found
		\return A vector containing the coordinates of the quantile
		\details This is a pure virtual function. Refer to child documentation for specific implementation details
		*/
		virtual Eigen::VectorXd GetQuantile(double Prob)const =0;
		//! Generates a single simulation from the copula
		/*!
		\return A row vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the copula
		\details This is equal to calling `ExtractSamples(1U)`
		\sa ExtractSamples()
		*/
		Eigen::RowVectorXd ExtractSample() const{return ExtractSamples(1U);}
		//! Generates a single simulation from the copula
		/*!
		\return A vector with number of elements equal to the dimensionality of the distribution representing a single extraction from the copula
		\details This is equivalent to ExtractSample() but returns an std::vector intead of an Eigen::RowVectorXd
		\sa ExtractSamples()
		*/
		std::vector<double> ExtractSampleVector() const;
		//! Generates multiple simulations from the copula
		/*!
		\param NumSamples The number of simulation to run
		\return A map that has as keys the index of the dimension (starting from 0) and as values a vector containing the simulation results for that dimension
		\details This function generates NumSamples simulation from the current copula and returns them in a map form.
	
		If NumSamples is 0 or the distribution is invalid, an empty map is returned
		*/
		std::map<unsigned int,std::vector<double> > ExtractSamplesMap(unsigned int NumSamples) const;
		//! Computes the probability density function of the copula in correspondence of the supplied coordinates
		/*!
		\param Coordinates  A vector containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is an overloaded version of GetDensity(const Eigen::VectorXd& Coordinates, bool GetLogDensity)const
		*/
		double GetDensity(const std::vector<double>& Coordinates)const;
		//! Computes the copula function in correspondence of the supplied coordinates
		/*!
		\param Coordinates A vector containing the coordinates of the point for which the cdf should be computed
		\return The value of the copula function
		\details This is an overloaded version of GetCumulativeDesity(const Eigen::VectorXd&, bool, unsigned int)const
		*/
		double GetCumulativeDesity(const std::vector<double>& Coordinates)const;
		//! Computes the inverse copula function in correspondence of the supplied probability
		/*!
		\return A vector containing the coordinates of the quantile
		\details This is equivalent to GetQuantile() but returns an std::vector intead of an Eigen::VectorXd
		*/
		std::vector<double> GetQuantileVector(double Prob)const;
	#ifdef mvPackageUnsafeMethods 
		/** \name Unsafe Methods
		The methods in this group use unsafe memory access or return arrays allocated on the heap that must be manually deleted.

		These functions are normally not compiled for safety reasons. To use them, the **mvPackageUnsafeMethods** symbol must be defined at compile time
		\{
		*/
		//! Computes the inverse copula function in correspondence of the supplied probability
		/*!
		\return A dynamically allocated array containing the coordinates of the quantile
		\details This is equivalent to GetQuantile() but returns an array intead of an Eigen::VectorXd. If it can't be calculated, NULL is returned
		\warning This function will return a matrix allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		double* GetQuantileArray(double Prob);
		//! Computes the copula function in correspondence of the supplied coordinates
		/*!
		\param Coordinates An array containing the coordinates of the point for which the cdf should be computed
		\return The value of the copula function
		\details This is an overloaded version of GetCumulativeDesity(const Eigen::VectorXd& Coordinates, bool UseGenz, unsigned int NumSimul)
		\warning This function will search for a number of elements equal to the dimensionality of the distribution in the array. This may mean accessing unallocated memory blocks if the supplied array is not big enough
		*/
		double GetCumulativeDesity(double* Coordinates)const;
		/**
		\brief Computes the probability density function of the copula in correspondence of the supplied coordinates
		\param Coordinates An array containing the coordinates of the point for which the pdf should be computed
		\return The value of the probability density function
		\details This is an overloaded version of GetDensity(const Eigen::VectorXd&, bool)
		\warning This function will search for a number of elements equal to the dimensionality of the distribution in the array. This may mean accessing unallocated memory blocks if the supplied array is not big enough
		*/
		double GetDensity(double* Coordinates)const;
		/**
		\brief Generates a single simulation from the copula
		\return A dynamically allocated array with number of elements equal to the dimensionality of the copula representing a single extraction from the distribution
		\details This is equivalent to ExtractSample() but returns an array intead of an Eigen::RowVectorXd. If it can't be calculated, NULL is returned
		\warning This function will return an array allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		double* ExtractSampleArray() const;
		/**
		\brief Generates a single simulation from the copula
		\param NumSamples The number of simulation to run
		\return A dynamically allocated matrix with number of columns equal to the dimensionality of the copula and number of rows equal to the number of simulations representing multiple draws from the copula
		\details This is equivalent to ExtractSamples() but returns a matrix intead of an Eigen::MatrixXd. If it can't be calculated, NULL is returned
		\warning This function will return a matrix allocated on the heap. If the user doesn't take care of deleting it, this will lead to memory leaks
		*/
		double** ExtractSamplesMatix(unsigned int NumSamples) const;
		/// \}
	#endif
	};
}
#endif // AbstarctArchimedeanCopula_h__